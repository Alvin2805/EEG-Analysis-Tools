/*############################################################################


              c行列の係数を導出するための関数


            voif inverse_of_g_matrix (double **g_matrix,char *g_fname);

	      
	戻り値  無し （c行列の係数値のアドレスをかえす)



############################################################################*/

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include"CSD.h"



Inverse_of_g_matrix(double **inv_g_mat,char *g_fna)
{
    
    
    
    int NUM,MAT,MAT2,MAT3;
    int counter;         /*####### 計算するcの変数の数の調整  #######*/
    int	counter1 ;       /*####### 計算するcの方程式の数の調整  #######*/
    int	counter2 ;        /*####### Cn の値判明段階によるcの変数と方程式の数の調整 
		      #####*/

    double  **coeffcient_of_c;    /*方程式時での変数cの係数*/
    double  **g_matrix;           /*方程式時でのg行列の係数*/
    double  *sum;                  /*方程式時での右辺数値*/
    

    char box[100];                  /*不必要文字列格納*/
    

    double kensa_d[MATRIX+1][MATRIX+1];
    FILE *octave_f;
    FILE *out_file;
    FILE *g_matrix_file;



    /*####################  メモリ確保と初期化  ##########################*/
        
    coeffcient_of_c = (double **)calloc(MATRIX + 1,sizeof(double *));
    if(coeffcient_of_c == NULL){
	puts("coeffcient_of_c のメモリが確保できません。");
	exit(1);
    }
    for(MAT=0;MAT<=MATRIX;MAT++){
	*(coeffcient_of_c + MAT) = (double *)calloc(MATRIX+1,sizeof(double ));
	if(*(coeffcient_of_c + MAT) == NULL){
	    puts("coeffcient_of_c のメモリが確保できません。");
	    exit(1);
	}
    }
    
    g_matrix = (double **)calloc(MATRIX,sizeof(double *));
    if(g_matrix == NULL){
	puts("g_matrix のメモリが確保できません。");
	exit(1);
    }
    for(MAT=0;MAT<MATRIX;MAT++){
	*(g_matrix + MAT) = (double *)calloc(MATRIX,sizeof(double ));
	if(*(g_matrix + MAT) == NULL){
	    puts("g_matrix のメモリが確保できません。");
	    exit(1);
	}
    }
       
    
    /*####################################################################*/


    /*########## g行列を代入 ###############*/

    g_matrix_file=fopen(g_fna,"r");
    if(g_matrix_file == NULL){
	printf("%s ファイルがオープンできません。(invese_of_g_matrix.c)\n",g_fna);
	exit(1);
    }
    
    for(NUM=0;NUM<2;NUM++)
	fgets(box,80,g_matrix_file);
    
    for(MAT2=0;MAT2<MATRIX;MAT2++){
	fscanf(g_matrix_file,"%s",box);
	for(MAT=0;MAT<MATRIX;MAT++){
	    fscanf(g_matrix_file,"%lf",&g_matrix[MAT][MAT2]);
	}
    }
  

    fclose(g_matrix_file);

    /*##########  方程式の係数の準備  ########*/ 
    
    for(MAT2=0;MAT2<MATRIX;MAT2++){
	for(MAT=0;MAT<=MATRIX;MAT++){
	    if(MAT==0)
		coeffcient_of_c[MAT][MAT2] = 1.0;
	    else
		coeffcient_of_c[MAT][MAT2] = g_matrix[MAT-1][MAT2];
	}
    }
    
    for(MAT=0;MAT<=MATRIX;MAT++){
	if(MAT==0)
	    coeffcient_of_c[MAT][MATRIX] = 0.0;
	else
	    coeffcient_of_c[MAT][MATRIX] = 1.0;
    }


        
        
    octave_f = fopen("inverse_file","w");
    if(octave_f==NULL){
	puts("inverse_file をオープンできません。");
	exit(1);
    }
    
    
    fprintf(octave_f,"M=[");

    for(MAT2=0;MAT2<=MATRIX;MAT2++){
	for(MAT=0;MAT<=MATRIX;MAT++){
	    fprintf(octave_f,"%lf ",coeffcient_of_c[MAT][MAT2]); 
	    if(MAT!=MATRIX)
		fprintf(octave_f,",");
	    else if(MAT==MATRIX){
		if(MAT2!=MATRIX)
		    fprintf(octave_f,";");
	    }
	}
    }
    

    fprintf(octave_f,"];\n");
    fprintf(octave_f,"a=inv(M);\n");
    fprintf(octave_f,"save F_inv_dat a;\n");
    fclose(octave_f);
    
    system("../OCT/octave-2.0.16/src/octave -q inverse_file ");
    
    /*############  逆行列の変数の用意  ##################*/


    octave_f = fopen("F_inv_dat","r");
    if(octave_f == NULL){
	puts("F_inv.dat ファイルがオープンできません.");
	exit(1);
    }
    
        
    for(NUM=0;NUM<5;NUM++){
	fgets(box,80,octave_f);
    }
        
    for(MAT2=0;MAT2<=MATRIX;MAT2++){
	for(MAT=0;MAT<=MATRIX;MAT++){
	    fscanf(octave_f,"%lf",&inv_g_mat[MAT][MAT2]);
	}
    }

    fclose(octave_f);
    
     
    for(MAT3=0;MAT3<=MATRIX;MAT3++){
	for(MAT2=0;MAT2<=MATRIX;MAT2++){
	    kensa_d[MAT2][MAT3] =0.0;	
	    for(MAT=0;MAT<=MATRIX;MAT++){
		kensa_d[MAT2][MAT3] += coeffcient_of_c[MAT][MAT3]*inv_g_mat[MAT2][MAT];
		}
	    //printf("%lf ",kensa_d[MAT2][MAT3]);
	}
	//printf("\n");
    }

    
     
   
}

